\documentclass[oneside, 11pt]{book}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Configuration
%
\input{packages.tex}
\input{formatting.tex}
\input{math_util.tex}

\makeindex
\makenomenclature
\makeglossaries

\author{{Rollen S. D'Souza}\\
        {Software Engineering Undergraduate}\\
        {Department of Electrical \& Computer Engineering}\\
        {\texttt{rs2dsouz@edu.uwaterloo.ca}}}
\title{\textbf{SE499 Report --- Path Following Controllers}}
\date{}

\setcounter{tocdepth}{1}

\bibliography{report.bib}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Document
%
\begin{document}

% Title page
\maketitle

\frontmatter
\section*{Acknowledgments}
The author thanks Professor Christopher Nielsen for his guidance in developing the required intuition and mathematical tools for path following control design. Plots and simulations were partly written in Mathworks MATLAB under a student licence. Other simulations were written using C++ linked with the Boost library and Catch test framework.

\begin{flushright}
Rollen S. D'Souza\\
Software Engineering Undergraduate\\
University of Waterloo\\
\texttt{rs2dsouz@edu.uwaterloo.ca}
\end{flushright}

\tableofcontents

\printnomenclature[3cm]

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Acronyms and Initialisms}
\printglossary[title=Acronyms and Initialisms]

%%%%%%%%%%%%      MAIN MATTER      %%%%%%%%%%%%
\mainmatter
\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}

\chapter{Introduction}

\section{Background}
A common control objective for mobile robots involves tracking a trajectory in the space the robot operates in. This space is defined as the task space of the robot, denoted as $\mathcal{T}$. Often the structure of this space is unknown --- along with the goal --- and the robot must first explore the world using an exploration and mapping algorithm before deciding on a goal and path.  This paper is instead concerned with a restricted subset of this problem.

Consider a differential drive robot starting at location $(0,0)$, placed in a world with an unknown number of obstacles, that is given the objective to reach position $(x,y)$ in task space without colliding with obstacles. A two-pronged approach can be taken to safe-guard from collisions:
\begin{enumerate}
    \item Plan a path that can be followed successfully by the robot and does not intersect with any obstacles for all future time.
    \item Design a controller that ensures sufficiently fast convergence to the path and provides a guarantee, under reasonable assumptions, that the robot will not leave the path.
\end{enumerate}

Planning a path is a field in its own right. The most practical, and dominant, philosophy to path planning involves sampling $\mathcal{T}$ and incrementally building a path to the goal region. The sampling algorithm is critical to performance and effective coverage of $\mathcal{T}$. If the sampling technique does not adequately sample the space in question the algorithm may take considerably longer to generate a path that reaches $\mathcal{G}$. Incorporated in these algorithms is the ability to test the feasibility of a path such as whether any collisions would occur with the known environment and whether any other differential constraints of the robot are broken. This addition ensures that infeasible paths are rejected early instead of wasting time developing a path that is known to be infeasible. Of course, the astute reader notes that this type of path generation often creates discrete segments that lead to the goal. There are techniques in literature to develop smooth paths incrementally in coordination with a sampling algorithm but these are considered outside the scope of this work \cite{Yang14}. Other advanced approaches to generate smooth paths exist that rely on construction of a vector field over $\mathcal{T}$ \cite{LaValle06} but these are relatively complex.

Instead this report takes a simpler approach that generates a smooth function out of the discrete waypoints generated by the relatively simple Rapidly exploring Randomized Tree (RRT) algorithm. The smooth function generated is a polynomial spline, a stitched sequence of possibly distinct polynomials that preserve a set of continuity conditions at the stitch-points. After generation, the spline is tested again for feasibility before being propogated to the controller. There are apparent performance issues in this approach addressed in Section \ref{sec:planning}.

Independently the field of non-linear control theory developed techniques to follow arbitrary paths. Standard control techniques tend to yield poor results in tracking a path. A number of techniques in literature exist to drive a robot towards a path and converge upon it. However, most of these techniques do not provide invariance once on the path\cite{Gill15}. This lack of invariance reduces the robustness of the technique as the controller may not stay on the path even under perfect environmental conditions! This motivated the development of a new family of path following controllers that treat the path as an invariant set that is then stabilized through linear control, described in Section \ref{sec:control}. This family of controllers use transverse feedback linearization to reformulate the problem and assist in constructing a linear controller that compensates for the non-linearities imposed by the path.

This report discusses a few methods to planning and control for the purpose of driving a differential drive robot towards a goal.

\section{Notation and Report Organization}
\nomenclature{$\mathcal{T}$}{Mobile robot task space.}
\nomenclature{$\mathcal{T}_{(w,h)}$}{Rectangular mobile robot task space with width $w$ and height $h$.}
\nomenclature{$\vec{x}$}{A vector in $\R$.}
\nomenclature{$\vec{x}_i$}{The $i$-th component of vector $\vec{x}$}
\nomenclature{$\vec{M}$}{A matrix. Can be assumed real unless stated otherwise.}
\nomenclature{$\vec{M}_{(i,j)}$}{The value at the $i$-th row and $j$-th column of matrix $\vec{M}$. The variables may have a $:$ substituted to indicate selection of all values in that dimension, similar to that found in the Matlab grammar.}
This report assumes proficiency in multi-variable calculus and basic control theory. As a result, any results taken from theory of dynamical systems and other advanced undergraduate mathematical courses are stated and cited from a source used by the author. Scalars are denoted as $x$, vectors as $\vec{x}$ and matrices as $\vec{X}$. Time derivatives are denoted using Newton's dot notation and any other derivatives are denoted using primes if the independent variable is clear and Leibniz notation otherwise.

In practice, planning algorithms generally precede control. However this report instead defers discussion of planning until after describing control methodologies in Section \ref{sec:control}. This content placement is intended to give the reader a better intuition for the decisions made at planning stage.

\section{Problem Statement}
Let the task space, without loss of generality, be the rectangular space  $\mathcal{T}_{(w,h)} = \{(x,y)\in\mathbb{R}^2 : 0 \leq x \leq w \wedge 0 \leq y \leq h\}$. For simplicity, consider the kinematic model of a differential drive robot with the combined position and orientation state vector $\vec{x}=\trans{(x,y,\theta)}$. The robot has a, possibly controllable, forward velocity $v:(\vec{x}, t)\mapsto\R$ with $v>0$ and a controllable turning rate $u:(\vec{x}, t)\mapsto\R$. The observation is simply the robot's current position. Unless stated otherwise, $v$ is assumed constant. The kinematic dynamics follow as,
\begin{align}
    \vec{f}(\vec{x}) &=
        \begin{bmatrix}
            v~cos(\vec{x}_3)\\
            v~sin(\vec{x}_3)\\
            0
        \end{bmatrix} \nonumber \\
    \vec{g} &= \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} \nonumber \\
    \vec{H} &=
        \begin{bmatrix}
            1 & 0 & 0\\
            0 & 1 & 0
        \end{bmatrix} \nonumber \\
    \vec{\dot{x}} &=
        \vec{f}(\vec{x})
        +
        \vec{g} u \nonumber \\
    \vec{h}(\vec{x}) &= \vec{H}\vec{x}
    \label{eqn:basic_kinematic_model}
\end{align}
The robot, at some unknown finite time, must arrive at the goal region $\mathcal{G}\subset\mathcal{T}$. Note there is no restriction in how it arrives in this region other than it does so safely. Starting at time $t=0$ and then at a regular time interval $\Delta_p$, the robot observes the world and decides, based on the observation, whether a new plan is required to approach the goal region. This may occur, for example, when the robot observes a new obstacle that the robot's currently planned path intersects. The simplest and most widely used planning algorithms are involve the generation of a tree that explores the current model of the world. This family of algorithms generate a sequence of waypoints. This is then used to generate a path $\sigma: \lambda \mapsto \mathcal{T}$ where $\lambda$ is an arbitrary parameterization of the curve. Without loss of generality, this report assumes $\lambda\in[0,1]$.

The path $\sigma_1$ is fed into the path following control which guides the robot over time towards, and along, the path in order to arrive in $\mathcal{G}$. Further, the control algorith must converge towards the path in a manner that is both guaranteed and as fast as possible. It must also faithfully follow the path, in order to reduce the chances of replanning. Given that the robot may not have a perfect model of the world, i.e. is not aware of all obstacles, a replan may still occur. The planning algorithm is required to design the new $\sigma_2$ so as to preserve any properties the control algorithm requires to stay on the trajectory continuously.

\chapter{Control}\label{sec:control}
Three control strategies are considered for path following. The simplest controller, in terms of design and implementation, is the point-chasing controller. The other two techniques rely on the approach of transverse feedback linearization which decomposes the path following problem into transverse and tangential dynamical systems.

This section assumes the path is of the form in Equation \ref{eqn:quintic}. The matrix representation of a quintic polynomial is chosen for succint representation.
\begin{align}
    &\vec{P}\in\R^{2\times6} \nonumber \\
    &\sigma(\lambda) =   \vec{P}
                        \begin{bmatrix}
                            1 \\
                            \lambda^1 \\
                            \lambda^2 \\
                            \lambda^3 \\
                            \lambda^4 \\
                            \lambda^5
                        \end{bmatrix}
    \label{eqn:quintic}
\end{align}

\section{Point-Chasing (Tracking) Controller}
A point-chasing (tracking) controller involves treating the parameter $\lambda$ of the path $\sigma$ as a function of time, $t$, and designing a controller that converges to this moving point. In order to apply this strategy, the control is designed around a point that leads the robot's current position. That is, consider an observation $\vec{y}_l(\vec{x}(t)) = \vec{H}\vec{x} + l\vec{tau}(\vec{x}_3)$ for some $l\in\R$ and $l > 0$, where $\vec{tau}(\vec{x}_3)=\trans{(cos(\vec{x}_3),sin(\vec{x}_3))}$. We let $\vec{y}_{ref}(t) = \sigma\left(\lambda(t)\right)$. The introduction and restriction on the parameter $l$ is clear in the derivation.

There is one modification made to the differential drive robot to allow for this controller design. The differential drive robot must permit speed control. Therefore we take, for this sub-section alone, the dynamical system to be of the form,
\begin{equation}
    \vec{\dot{x}} = \vec{f}_t(\vec{x}) =
        \begin{bmatrix}
            v~cos~\vec{x}_3 \\
            v~sin~\vec{x}_3 \\
            u
        \end{bmatrix}
\end{equation}

Define the position error $\vec{e} = \vec{y}_l - \vec{y}_{ref}$ and take the time derivative to form a new dynamical system in terms of the path error,
\begin{align*}
    \vec{\dot{e}}   &= \vec{\dot{y}_l} - \vec{\dot{y}_{ref}}\\
                    &= \vec{H}(\vec{f}(\vec{x})) + l\vec{\dot{\tau}} - \sigma'(\lambda(t))\dot{\lambda}\\
                    &= \begin{bmatrix} v~cos~\vec{x}_3 \\ v~sin~\vec{x}_3 \end{bmatrix}
                        +
                        \begin{bmatrix} -l~sin\vec{x}_3 \\ l~cos~\vec{x}_3 \end{bmatrix} u
                        -
                        \sigma'(\lambda(t))\dot{\lambda}\\
                    &=  \begin{bmatrix}
                            -l~sin\vec{x}_3 & cos~\vec{x}_3 \\
                            l~cos~\vec{x}_3 & sin~\vec{x}_3 \\
                        \end{bmatrix}
                        \begin{bmatrix}
                            u \\ v
                        \end{bmatrix}
                        -
                        \sigma'(\lambda(t))\dot{\lambda}
\end{align*}
At this point the reader may observe that the matrix multiplying the control signals is invertible if and only if $l$ is non-zero. Let the dynamics of $\vec{\dot{e}}$ be governed by proportional feedback control. That is, $\vec{\dot{e}}=\vec{K}\vec{e}$ with $\vec{K}\in\R^{2\times2}$ and Hurwitz. Then the control signals may be solved for,
\begin{align*}
    \begin{bmatrix}
        u \\ v
    \end{bmatrix}   &=  \begin{bmatrix}
                            -l~sin\vec{x}_3 & cos~\vec{x}_3 \\
                            l~cos~\vec{x}_3 & sin~\vec{x}_3 \\
                        \end{bmatrix}^{-1}
                        \left[
                            \vec{K}\vec{e} + \sigma'(\lambda(t))\dot{\lambda}(t)
                        \right]
\end{align*}

\section{Transverse Feedback Linearization}
A variety of techniques were designed to address the issues observed in the point chasing controller. One of these techniques is transverse feedback linearization. Transverse feedback linearization is the mathematical reformulation of system dynamics into transversal and tangential components with respect to the closest point to the path. This restatement of the problem allows for the capturing of the path dynamics --- combining that with the original system dynamics --- and permits cancellation of non-linearities introduced by the path as it affects the system.

The technique was generalized in \cite{Nielsen06} for aperiodic paths and then further expanded in \cite{Hladio13}. The approaches defined in those works restricted their design to following simple curves, such as circles. Gill et al., in \cite{Gill15}, applied the technique to a larger class of paths, specifically splines in $C^2$. Note that their work is not restricted to polynomial splines and in fact applies to any functions that are stitched at waypoints preserving $C^2$ continuity on the whole parameterized domain. As stated previously, it is assumed in this work that these splines are quintic polynomials in order to provide a relevant benchmark comparison.

\subsection{General Form}\label{sec:general_tfl}
Recall the kinematic model for a differential drive robot, from Equation \ref{eqn:basic_kinematic_model}.

As before, let the path $\sigma:\lambda\mapsto\R^2$ with the additional requirement that it be $C^2$ everywhere. We define a new state vector $\vec{\xi}=\trans{(\xi_1, \xi_2)}$ where $\xi_1$ is left undefined for now. One can consider $\xi_1$ as the signed tracking error of the robot with respect to the path. The variation of this state is what differentiates the variety of techniques used. When the path is well known and simple --- such as a circular arc --- this state may be expressed in closed form. This is not always the case. Let us then define $\xi_2=\dot{\xi_1}$. Chain rule gives,
\begin{align*}
    \xi_2   &= \dot{\xi_1}\\
            &= \frac{\partial\xi_1}{\partial\vec{x}}\dot{\vec{x}}\\
            &= \nabla_{\vec{x}}\xi_1
                \begin{bmatrix}
                    v~cos(\vec{x}_3)\\
                    v~sin(\vec{x}_3)\\
                    u
                \end{bmatrix}
\end{align*}
Under the assumption that this error is independent of robot heading we can further simplify the expression such that $\xi_2=\nabla_{\vec{x}}\xi_1 f(\vec{x})=\lie{f}\xi_1$. $\lie{f}\xi_1$ is known as the Lie derivative of $\xi_1$ with respect to the vector field $f(\vec{x})$. This then means the control signal has no impact on our state. This motivates finding the time derivative of $\xi_2$. Using properties of Lie derivatives, it is not difficult to show that $\xi_2=\lie{gf}(\xi_1) u + \lie{ff}(\xi_1)$. This yields the transverse feedback linearized system dynamics,
\begin{equation}
    \vec{\dot{\xi}}
    =
    \begin{bmatrix} \xi_2 \\ \lie{gf}(\xi_1) u + \lie{ff}(\xi_1) \end{bmatrix}
    \label{eqn:tfl_dynamics}
\end{equation}
We would like to control the system using linear control, so we set $\xi_2=\vec{k}\vec{xi}$ and solve for the non-linear control signal $u$. We arrive at the control generation equation for transverse feedback linearization,
\begin{equation}
    u = \frac{\vec{k}\vec{xi} - \lie{ff}(\xi_1)}{\lie{gf}(\xi_1)}
\end{equation}
The reader may wonder under what conditions $\lie{gf}(\xi_1)$ is non-zero. This is not apparent, although intuition may guide us. Since $\lie{gf}(\xi_1)$ is what scales the control signal, and therefore it may vanish whenever the control signal has no instantaneous impact on the change in the orthogonal error. This may occur, for example, when the differential robot is facing towards the nearest point.

\subsection{Sylvester Approach}
The Sylvester methodology relies on the theoretical developments of elimination theory. Elimination theory investigates the theoretical methods that discover common roots of polynomials. The essential idea is to reformulate Equation \ref{eqn:quintic} into a system of homogenous linear equations that has a non-trivial kernel \cite{Sederberg84}. This non-trivial kernel allows for the derivation of an implicit representation of the path, otherwise known as a level set, that can then be stabilized by the transverse feedback linearization. First let us impose a regularity condition.

\begin{assumption}
    Path is self-intersection free.
    \begin{equation*}
        \forall \lambda_1, \lambda_2 \in\R : \sigma(\lambda_1) = \sigma(\lambda_2) \Leftrightarrow \lambda_1 = \lambda_2
    \end{equation*}
    \label{ass:self_intersect}
\end{assumption}

Take notice that there is no restriction on $\lambda$ in the assumption although work in this report does restrict the domain. Additionally, we need a result from linear algebra,

\begin{theorem}
    Given a system of $n$ homogenous linear equations in $n$ unknowns, $\vec{A}\vec{x}=0$, non-trivial solutions $x$ exist if and only if $\mdet~\vec{A}=0$. \label{thm:kernel}
\end{theorem}

Notice that if we formulate a new system from Equation \ref{eqn:quintic} that is square and homogenous, we will be able to eliminate $\vec{x}$ by instead considering the $\mdet~\vec{A}$. This is otherwise known as finding the resultant. Homogenizing the path simply requires treating $\sigma_1$ and $\sigma_2$ as constants $x_1$ and $x_2$, moving them into the polynomial matrix $\vec{P}$. We call this modified matrix $\vec{Q}$. With this modification, we need only construct a square system out of $\vec{Q}$. In order to construct a square linear system, we consider multiplying both polynomials in the first and second component of $\sigma$ by increasing powers of $\lambda$ until we have generated a sufficient number of equations. For two quintics, we must multiply the polynomials by powers of $\lambda$ up til $\lambda^5$, arriving at Equation \ref{eqn:inhomog_poly}.

\begin{equation}
    \begin{bmatrix}
        & \vec{Q}_{1:} & \vec{0}_{1\times 6} \\
        0 & \vec{Q}_{1:} & \vec{0}_{1\times 5} \\
        \vec{0}_{1\times 2} & \vec{Q}_{1:} & \vec{0}_{1\times 4} \\
        \vec{0}_{1\times 3} & \vec{Q}_{1:} & \vec{0}_{1\times 3} \\
        \vec{0}_{1\times 4} & \vec{Q}_{1:} & \vec{0}_{1\times 2} \\
        \vec{0}_{1\times 5} & \vec{Q}_{1:} & \vec{0}_{1\times 1} \\
        \vec{0}_{1\times 6} & \vec{Q}_{1:} & \\
        & \vec{Q}_{2:} & \vec{0}_{1\times 6} \\
        0 & \vec{Q}_{2:} & \vec{0}_{1\times 5} \\
        \vec{0}_{1\times 2} & \vec{Q}_{2:} & \vec{0}_{1\times 4} \\
        \vec{0}_{1\times 3} & \vec{Q}_{2:} & \vec{0}_{1\times 3} \\
        \vec{0}_{1\times 4} & \vec{Q}_{2:} & \vec{0}_{1\times 2} \\
        \vec{0}_{1\times 5} & \vec{Q}_{2:} & \vec{0}_{1\times 1} \\
        \vec{0}_{1\times 6} & \vec{Q}_{2:} & \\
    \end{bmatrix}
    \begin{bmatrix}
        1 \\
        \lambda^1 \\
        \lambda^2 \\
        \lambda^3 \\
        \lambda^4 \\
        \lambda^5 \\
        \lambda^6 \\
        \lambda^7 \\
        \lambda^8 \\
        \lambda^9 \\
        \lambda^{10} \\
        \lambda^{11}
    \end{bmatrix}
    =
    \vec{S}
    \begin{bmatrix}
        1 \\
        \lambda^1 \\
        \lambda^2 \\
        \lambda^3 \\
        \lambda^4 \\
        \lambda^5 \\
        \lambda^6 \\
        \lambda^7 \\
        \lambda^8 \\
        \lambda^9 \\
        \lambda^{10} \\
        \lambda^{11}
    \end{bmatrix}
    \label{eqn:inhomog_poly}
\end{equation}

Carefully note that the tail of $\vec{Q}_{1:}$ and $\vec{Q}_{2:}$ contain a linear term in $x_1$ and $x_2$ respectively. Therefore if the matrix has a non-trivial kernel, i.e. its determinant vanishes as per Theorem \ref{thm:kernel}, both $x_1$ and $x_2$ satisfy the polynomial equations. This motivates the definition of the zero level set, $s(x_1, x_2) = \det~S$. This method assumes the matrix $S$ doesn't have trivially vanishing determinant, such as if the leading coefficients of both polynomials $\sigma_1$ and $\sigma_2$ are equal. In that case, extensions to the method exist\cite{Sederberg84}.

Now we can define $\xi_1$, the distance from the robot to the path, as the level set function $\xi_1 = (s\circ h)(\vec{x})$. Observe that $\xi_1$ is only dependent on $x_1$ and $x_2$. Define $\xi_2 = \dot{\xi}_1 = \nabla_{(x_1, x_2)}s~\vec{H}\vec{f}(\vec{x})$. To complete the control system, we must differentiate $\xi_2$ in time. We expect Equation \ref{eqn:tfl_dynamics} to emerge naturally.
\begin{align*}
    \dot{\xi}_2 &=  \frac{d}{dt}\left[\nabla_{(x_1, x_2)}s\right]\vec{H}\vec{f}(\vec{x})
                    +
                    \nabla_{(x_1, x_2)}s\frac{d}{dt}\left[\vec{H}\vec{f}(\vec{x})\right]\\
                &=  \trans{\left(\vec{H}\vec{f}(\vec{x})\right)}\frac{\partial}{\partial(x_1, x_2)}\left[\nabla_{(x_1, x_2)}s\right]\vec{H}\vec{f}(\vec{x})
                    +
                    \nabla_{(x_1, x_2)}s\vec{H}\frac{\partial\vec{f}}{\partial\vec{x}}\vec{g}u\\
                &= \lie{ff} + \lie{gf}u
\end{align*}
The controller implementation follows from Section \ref{sec:general_tfl}.

\subsection{Serret-Frenet Frame Approach}
\nomenclature{$\Rot{\theta}$}{Counter-clockwise rotation matrix in $\R^2$ of angle $\theta$.}
\nomenclature{$B_\epsilon(\vec{x})$}{Open ball of radius $\epsilon$ centred about $\vec{x}$ in the appropriate vector space.}
First we must impose an extra regularity condition, in addition to Assumption \ref{ass:self_intersect} in order for this controller to work.
\begin{assumption}
    Existence and uniqueness of nearest point on the curve, the operating point.
    \begin{flalign*}
        \forall \vec{h}(\vec{x}) : \exists \lambda_*\in[0,1], \epsilon > 0 : &\\
            & \vec{h}(\vec{x})\in B_\epsilon\left(\sigma(\lambda_*)\right)\\
            & \forall s \in \sigma(\lambda)\cap B_\epsilon\left(\sigma(\lambda_*)\right), s \neq \sigma(\lambda_*) : \enorm{\vec{h}(\vec{x}) - \sigma(\lambda_*)} < \enorm{\vec{h}(\vec{x}) - s}
    \end{flalign*}
    \label{ass:unique_operating}
\end{assumption}

$\lambda_*$ is defined as the operating point. It is not difficult to see that this point also has the property that $\sigma'(\lambda_*)$ is orthogonal to the error. A linear basis that spans $\R^2$ is built from $\lambda_*$. Let the first basis vector $\vec{e}_1 = \sigma'(\lambda_*)(\enorm{\sigma'(\lambda_*)})$. The second basis vector can be formed through a 90 degree rotation, such that $\vec{e}_2 = \Rot{\frac{\pi}{2}}\vec{e}_1$. Relying on the intuition of previous derivations, we consider $\xi_1 = \trans{\vec{e}_2}\left(\vec{h}(\vec{x}) - \sigma(\lambda_*)\right)$. In words $\xi_1$ is the orthogonal tracking error with the active operating point. We complete the dynamical system state by differentiating $\xi_1$ to find $\xi_2$,
\begin{align*}
    \xi_2   &=  \dot{\xi}_1\\
            &=  \trans{\vec{\dot{e}}_2}\left(\vec{h}(\vec{x}) - \sigma(\lambda_*)\right)
                +
                \trans{\vec{e}_2}\left(\vec{H}(\vec{f}(\vec{x}) + \vec{g}u) - \sigma'(\lambda_*)\dot{\lambda} \right)\\
            &=  \trans{\vec{\dot{e}}_2}\left(\vec{h}(\vec{x}) - \sigma(\lambda_*)\right)
                +
                \trans{\vec{e}_2}\left(\vec{H}(\vec{f}(\vec{x}) + \vec{g}u) - \sigma'(\lambda_*)\dot{\lambda} \right)
\end{align*}
We require a result from basic differential geometry in order to continue.
\begin{lemma}
    Let $\vec{v}_1(\lambda), \vec{v}_2(\lambda)$ be continuously differentiable functions that map to the unit circle in $\R^2$, such that $\vec{v}_2(\lambda)=\Rot{\frac{\pi}{2}}\vec{v}_1(\lambda)$. Then, the derivatives of the vectors are related by a (parameter-varying) scalar multiple of the opposing vector such that
    \begin{align*}
        \vec{v}'_1(\lambda) &= \kappa(\lambda)\vec{v}_2 \\
        \vec{v}'_2(\lambda) &= -\kappa(\lambda)\vec{v}_1
    \end{align*}
    \label{lem:sf_frame}
\end{lemma}
\begin{proof}
    Observe that $\trans{\vec{v}_1}\vec{v}_1=1$ identically over the domain. Differentiating gives $\trans{\vec{v}'_1}\vec{v}_1=0$. Since $\{\vec{v}_1,\vec{v}_2\}$ spans $\R^2$, $\trans{\vec{v}'_1}=\kappa(\lambda)\vec{v}_2$. This choice isn't unique but is convenient. It is worth mentioning that $\kappa$ must be continuous at minimum. Further restrictions would be imposed by restrictions on the original functions. The derivative $\vec{v}'_2$ follows naturally from substituting $\vec{v}_2(\lambda)=\Rot{\frac{\pi}{2}}\vec{v}_1(\lambda)$.
\end{proof}
A generalization of Lemma \ref{lem:sf_frame} exists in higher dimensions and can be found in any modern differential geometry text\cite{Kuhnel06}. This lemma permits the elimination of the first and last terms in $\xi_2$. In practice, it may not always be possible to use --- or even find --- the closest point $\lambda_*$ and therefore there may be some error introduced in the system dynamics. An analysis of this effect is performed later. For now, we discard this term and observe that the control signal is in the kernel of $\vec{H}$ yielding a simple definition for $\xi_2$,
$$\xi_2 = \trans{\vec{e}_2}\vec{H}\vec{f}(\vec{x})$$

This definition may be intuitively described as the projection of the observable system dynamics on the orthogonal vector. Define a new state vector $\vec{\xi}=\trans{(\xi_1, \xi_2)}$. Once again we would like to take the time derivative of $\xi_2$ to complete the dynamical system. However two more Lemmas are required to help us take the time derivative of the basis vectors.
\begin{lemma}
    There exists a function $\varpi:\vec{h}\mapsto\lambda$ that generates the operating point $\lambda_*$ from the position of the robot (the observation). The derivative of $\varpi$ with respect to the observation is
    $$\dot{\varpi}(\vec{h}) = \frac{\trans{\vec{e}_1}}{\enorm{\sigma'(\lambda_*)}}$$
\end{lemma}
\begin{proof}
    Refer to Gill~\cite{Gill15}.
\end{proof}
\begin{lemma}
    The curvature, $\kappa(\lambda)$, is
    $$
        \kappa(\lambda) = \frac{\trans{\sigma''(\lambda)}\vec{e}_2}{\enorm{\sigma'(\lambda)}}
    $$
    \label{lem:kappa}
\end{lemma}
\begin{proof}
    Differentiate $\vec{e}_1$ with respect to $\lambda$ explicitly,
    \begin{align*}
        \frac{d\vec{e}_1}{d\lambda} &=  \frac{d}{d\lambda}\left[ \frac{\sigma'(\lambda)}{\enorm{\sigma'(\lambda)}}\right]\\
                                    &=  \frac{1}{\enorm{\sigma'(\lambda)}^2}\left[\sigma''(\lambda)\enorm{\sigma'(\lambda)}-\sigma'(\lambda)(\enorm{\sigma'(\lambda)})^{-1}\trans{\sigma''(\lambda)}\sigma'(\lambda)\right]\\
                                    &=  \frac{1}{\enorm{\sigma'(\lambda)}}\left[\sigma''(\lambda)-(\trans{\sigma''(\lambda)}\vec{e}_1)\vec{e}_1 \right]\\
                                    &=  \frac{1}{\enorm{\sigma'(\lambda)}}\left[\trans{\sigma''(\lambda)}\vec{e}_2\right]\vec{e}_2
    \end{align*}
    Likening the result with Lemma \ref{lem:sf_frame}, we see the statement is proven.
\end{proof}

Computing the derivative of $\xi_2$ we find,
\begin{align*}
    \dot{\xi}_2 &=  \trans{\vec{\dot{e}}_2}H\vec{f}(\vec{x})
                    +
                    \trans{\vec{e}_2}H\frac{\partial\vec{f}}{\partial\vec{x}}\left[\vec{f}(\vec{x}) + \vec{g}u\right]\\
                &=  \trans{(H\vec{f}(\vec{x}))}\vec{\dot{e}}_2
                    +
                    \trans{\vec{e}_2}H\frac{\partial\vec{f}}{\partial\vec{x}}\left[\vec{f}(\vec{x}) + \vec{g}u\right]\\
                &=  -\trans{(H\vec{f}(\vec{x}))}\vec{e}_1 \kappa(\lambda_*)\frac{\trans{\vec{e}_1}H\vec{f}(\vec{x})}{\enorm{\sigma'(\lambda_*)}}
                    +
                    \trans{\vec{e}_2}H\frac{\partial\vec{f}}{\partial\vec{x}}\vec{g} u\\
                &=  -\trans{(H\vec{f}(\vec{x}))}\vec{e}_1 \frac{\trans{\sigma''(\lambda)}\vec{e}_2}{\enorm{\sigma'(\lambda)}}\frac{\trans{\vec{e}_1}H\vec{f}(\vec{x})}{\enorm{\sigma'(\lambda_*)}}
                    +
                    \trans{\vec{e}_2}H\frac{\partial\vec{f}}{\partial\vec{x}}\vec{g} u\\
                &=  -\left[\trans{\vec{e}_1}H\vec{f}(\vec{x})\right]^2 \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    \trans{\vec{e}_2}H\frac{\partial\vec{f}}{\partial\vec{x}}\vec{g} u\\
                &=  \lie{ff}\xi_1 + \lie{gf}\xi_1 u
\end{align*}
This result completes the dynamical system and allows for the construction of the linear controller. However, we would like to simplify the above system to be in terms of only $\vec{\xi}$, if possible. A useful result that combines the knowledge of our model and formulation of the basis vectors is required.
\begin{lemma}
    The velocity of the robot may be decomposed through projections on the basis vectors,
    $$
        v = \sqrt{ \left(\trans{\vec{e}_2}\vec{H}\vec{f}(\vec{x})\right)^2 + \left(\trans{\vec{e}_1}\vec{H}\vec{f}(\vec{x})\right)^2 }
    $$
    Which implies that,
    $$
        \left(\trans{\vec{e}_1}\vec{H}\vec{f}(\vec{x})\right) = \sqrt{v^2 - \xi_2^2}
    $$
\end{lemma}

\begin{align*}
    \dot{\xi}_2 &=
                    -\left[\trans{\vec{e}_1}H\vec{f}(\vec{x})\right]^2  \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    \trans{\vec{e}_2}H\frac{\partial\vec{f}}{\partial\vec{x}}\vec{g} u\\
                &=
                    -\left(v^2 - \xi_2^2\right) \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    \trans{\vec{e}_2}H\frac{\partial\vec{f}}{\partial\vec{x}}\vec{g} u\\
                &=
                    -\left(v^2 - \xi_2^2\right) \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    \trans{\vec{e}_2}
                        \begin{bmatrix}
                            -v~\sin x_3 \\
                            v~\cos x_3
                        \end{bmatrix}
                    u\\
                &=
                    -\left(v^2 - \xi_2^2\right) \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    \trans{\vec{e}_2}\Rot{\frac{\pi}{2}}
                        \begin{bmatrix}
                            v~\cos x_3 \\
                            v~\sin x_3
                        \end{bmatrix}
                    u\\
                &=
                    -\left(v^2 - \xi_2^2\right) \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    \trans{\vec{e}_2}\Rot{\frac{\pi}{2}}\vec{H}\vec{f}(\vec{x}) u\\
                &=
                    -\left(v^2 - \xi_2^2\right) \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    \trans{\left(\Rot{-\frac{\pi}{2}}\vec{e}_2\right)}\vec{H}\vec{f}(\vec{x}) u\\
                &=
                    -\left(v^2 - \xi_2^2\right) \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    \trans{\vec{e}_1}\vec{H}\vec{f}(\vec{x}) u\\
                &=
                    -\left(v^2 - \xi_2^2\right) \frac{\trans{\vec{e}_2}\sigma''(\lambda)}{\trans{\sigma'(\lambda)}\sigma'(\lambda_*)}
                    +
                    u \sqrt{v^2 - \xi_2^2}\\
\end{align*}
Further simplification is not necessary as it is clear that $\left|\xi_2\right|$ must never equal $v$. Intuitively this means that the robot's speed must not be completely represented in the orthogonal direction -- towards the path. This concern motivates an analysis on whether stability may be guaranteed within a bounded volume that does not intersect the $\left|\xi_2\right|=v$ isoclines.

\subsubsection{Stability Analysis and Control Design}
The final control system, with proportional linear feedback, is
\begin{equation}
    \vec{\dot{\xi}} =   \begin{bmatrix}
                            0 & 1 \\
                            g_1 & g_2
                        \end{bmatrix}
                        \vec{\xi}
    \label{eqn:tfl_linear}
\end{equation}
We begin with a necessary result from Dynamical System Theory.
\begin{theorem}[(General) Lyapunov's Method]
    Let $\vec{\xi}_*$ be an equilibrium point of Equation \ref{eqn:tfl_linear}, $\Omega\subset\R^2$ be an open set containing $\xi_*$, and $V:\Omega\to\R$ be continuously differentiable such that
    \begin{enumerate}
        \item $V(\vec{\xi}_*) = 0, V(\vec{\xi}) > 0 \Leftrightarrow \vec{\xi}\neq\vec{\xi}_*$
        \item $\dot{V}(\vec{\xi})\leq 0, \vec{\xi}\in\Omega$
        \item The set $E = \left\{ \xi \in \Omega : \dot(V(\vec{\xi})) = 0 \right\}$ does not contain any whole orbits except $\vec{\xi}_*$ (LaSalle's Invariance Principle)
    \end{enumerate}
    Then all orbits in $\Omega$ asymptotically converge to $\vec{\xi}_*$.
    \label{thm:lasalle}
\end{theorem}
\begin{proof}
    See Liu \cite{Liu12}.
\end{proof}
Now we prove the main result,
\begin{theorem}[Arbitrarily Bounded Stability of Serret Frenet Control]
    For any $M\in\R$ and $M>0$, an $\Omega$ may be constructed such that,
    \begin{enumerate}
        \item $\sup_{\vec{\xi}\in\Omega}{\left|\xi_1\right|} = M$
        \item $\sup_{\vec{\xi}\in\Omega}{\left|\xi_2\right|} = v$
    \end{enumerate}
    Let $g_2 < 0$. Then, there exists a Lyapunov function $V:\Omega\to\R$ and gain $g_1$ that satisfies the requirements of Theorem \ref{thm:lasalle} such that the dynamical system is guaranteed to converge to the path.
\end{theorem}
\begin{proof}
    We use the method of undetermined coefficients over a quartic positive definite form. Let $V(\xi) = \xi_1^4 + a\xi_1^2\xi_2^2 + b\xi_2^4$. Choose $\Omega=\left\{\xi : V(\xi) = D\right\}$ for some $D\in\R$. Choose $b=Dv^{-4}$. Then,
    \begin{align*}
        \dot{V} &=  4\xi_1^3\dot{\xi}_1 + 2a\left[\xi_1\dot{\xi}_1\xi_2^2 + \xi_1^2\xi_2\dot{\xi}_2\right] + 4b\xi_2^3\dot{\xi}_2\\
                &=  4\xi_1^3\xi_2 + 2a\left[\xi_1\xi_2^3 + g_1\xi_1^3\xi_2 + g_2\xi_1^2\xi_2^2\right] + 4bg_1\xi_1\xi_2^3 + 4bg_2\xi_2^4\\
                &=  \left(4+2ag_1\right)\xi_1^3\xi_2 + 2\left(a + 2bg_1\right)\xi_1\xi_2^3 + \left(2a\xi_1^2\xi_2^2 + 4b\xi_2^4\right)g_2\\
                &=  \left(4+2ag_1\right)\xi_1^3\xi_2 + 2\left(a + 2Dv^{-4}g_1\right)\xi_1\xi_2^3 + \left(2a\xi_1^2\xi_2^2 + 4Dv^{-4}\xi_2^4\right)g_2\\
    \end{align*}
    Impose the requirement that cross-terms vanish identically. This gives restrictions on $a$ and $g_1$.
    \begin{align*}
        g_1 &= -\frac{v^2}{\sqrt{D}}\\
        a &= 2\frac{\sqrt{D}}{v^2}
    \end{align*}
    This pair uniquely defines $V$ as $V(\xi) = \xi_1^4 + 2\frac{\sqrt{D}}{v^2}\xi_1^2\xi_2^2 + \frac{D}{v^4}\xi_2^4$. Interestingly, this is actually the square of a quadratic form. Specifically,
    $$
        V(\xi) = \left[\xi_1^2 + \left(\frac{\sqrt{D}}{v^2}\right)\xi_2^2 \right]^2
    $$
    We can now see that the conditions on $\Omega$ are in fact observed with $D = M^4$. However, we still need to prove asymptotic stability. We now know that $\dot{V} = \left(2a\xi_1^2\xi_2^2 + 4Dv^{-4}\xi_2^4\right)g_2$. This function is zero on the $\xi_2=0$ axis. However, we note that since $g_1 \neq 0$, there are no equilibria on this axis. More importantly, no other whole orbits exist on this axis except for the equilibrium point, $\xi=\vec{0}$. By Theorem \ref{thm:lasalle}, the system is asymptotically stable as required.
\end{proof}

\chapter{Planning}\label{sec:planning}

\section{RRT}

\section{Polynomial Splining}

\subsection{Constrained Spline}

\subsection{Loosely Constrained Spline}\label{sec:restrictpolyfit}

\chapter{Case Study}

\section{Baseline Benchmarks}
An initial performance comparision on the controllers was performed in MATLAB with a quintic polynomial path generated using the technique described in Section \ref{sec:restrictpolyfit}. The polynomial has small coefficients with enough curvature to have interesting behaviour but not too high curvature that may adversely affect all controllers.

\subsection{Tracking Controller}

\subsection{Transverse Feedback Linearization Controllers}

\backmatter
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{References}
\markright{\textsc{References}}
\printbibliography[title=References]

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}
\markright{\textsc{Index}}
\printindex

\end{document}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
